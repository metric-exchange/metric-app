<order-price>

    <div class="order-line exchange-price">
        <div class="order-input">
            <div id="price-switch" class="switch-button" onclick={ changePriceDirection } if={ props.orderFactory.order.isLimitOrder() || !props.orderFactory.order.sellPrice.price.value.isNaN() }>
                <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="15" cy="15" r="15" fill="#262626"/>
                    <path d="M18 11L19.5 12.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M19.5 12.5H13C12 12.5 10.5 12.5 10.5 14.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12 19L10.5 17.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M10.5 17.5L17.0138 17.5C18.0138 17.5 19.5138 17.5 19.5138 15.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            <div class="max-amount-loader" if={ props.orderFactory.order.isMarketOrder() && props.orderFactory.order.sellPrice.price.value.isNaN() }>
                <loader/>
            </div>
        </div>
        <div class="order-input" if={ props.orderFactory.order.isLimitOrder() }>
            <div class="input-sticky-placeholder" if={ !props.orderFactory.order.sellPrice.price.value.isNaN() }>{ this.i18next.t('order.price_direction', props.orderFactory.order.sellPrice.priceTokens()) }</div>
            <input id="order-price-input"
                   type="number"
                   oninput={ updatePrice }
                   placeholder="{ this.i18next.t('order.price_direction', props.orderFactory.order.sellPrice.priceTokens()) }"
                   step="any"
            />
        </div>
        <div class="order-input" if={ props.orderFactory.order.isMarketOrder() }>
            <div class="input-sticky-placeholder" if={ !props.orderFactory.order.sellPrice.price.value.isNaN() }>{ this.i18next.t('order.price_direction', props.orderFactory.order.sellPrice.priceTokens()) }</div>
            <div id="market-price">{ props.orderFactory.order.sellPrice.displayPrice().toFixed(4) } ({ state.priceImpact.toFixed(2) }%)</div>
        </div>
    </div>

    <script>

        import {
            OrderEventActions,
            OrderEventProperties,
            OrderEventSource
        } from "../../../common/order/OrderEventSource";
        import Loader from '../../loader/index.riot'
        import {BigNumber} from "@0x/utils";

        export default {
            components: {
                Loader
            },
            config: {
                event: new OrderEventSource(OrderEventProperties.Price, OrderEventActions.Input)
            },
            state: {
                priceImpact: 0
            },
            onMounted() {
                this.props.orderFactory.order.sellPrice.price.observe(this, 'onPriceChange')
                this.refreshMarketPrice()
            },
            onPriceChange(source) {
                if (source.property !== this.config.event.property || source.action !== this.config.event.action) {
                    if (this.props.orderFactory.order.isLimitOrder()) {
                        document.getElementById("order-price-input").value =
                            this.props.orderFactory.order.sellPrice.displayPrice().toFixed(4)
                        this.update()
                    } else {
                        this.setPriceImpact()
                    }
                }
            },
            updatePrice(e) {
                this.props.orderFactory.order.sellPrice.set(this.config.event, new BigNumber(e.target.value))
                this.update()
            },
            changePriceDirection() {
                this.props.orderFactory.order.sellPrice.invert()
                document.getElementById("price-switch").classList.toggle("transition-half-rotate")

                if (this.props.orderFactory.order.isLimitOrder()) {
                    document.getElementById("order-price-input").value =
                        this.props.orderFactory.order.sellPrice.displayPrice().toFixed(4)
                this.update()
                } else {
                    this.setPriceImpact()
                }
            },
            async setPriceImpact() {
                let marketPrice = await this.props.orderFactory.order.sellPrice.fetchDisplayMarketPrice()
                let quotePrice = this.props.orderFactory.order.sellPrice.displayPrice()

                let priceImpact = quotePrice.minus(marketPrice).multipliedBy(100).dividedBy(marketPrice)

                this.update({ priceImpact: priceImpact })
            },
            async refreshMarketPrice() {
                if (this.props.orderFactory.order.isMarketOrder()) {
                    await this.props.orderFactory.order.sellPrice.refreshMarketPrice()
                }
                setTimeout(async (obj) => { await obj.refreshMarketPrice() }, 30000, this)
            }
        }

    </script>

</order-price>
