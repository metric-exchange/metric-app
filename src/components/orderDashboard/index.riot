<order-dashboard>

    <div class="dashboard">

        <div class="order-form">
            <order-form
                    order-factory={ state.orderFactory }
                    set-market-order-type={ setMarketOrderType }
                    set-limit-order-type={ setLimitOrderType }
                    enable-hiding-game={ true }
            />
        </div>

        <div class="order-book" if={ this.isConnectedToEthereumMainNet() }>
            <order-book order-factory={ state.orderFactory }/>
        </div>

        <div class="trade-list" if={ this.isConnectedToEthereumMainNet() }>
            <trade-list/>
        </div>

        <div class="order-list" if={ this.isConnectedToEthereumMainNet() }>
            <order-list/>
        </div>

    </div>

    <script>

        import './index.css'
        import OrderForm from '../orderForm/index.riot'
        import OrderBook from '../orderBook/index.riot'
        import OrderList from '../orderList/index.riot'
        import TradeList from '../tradeList/index.riot'
        import {registerForTokenListUpdate} from "../../common/tokens/token_fetch";
        import {SwapOrderFactory} from "../../common/order/SwapOrderFactory";
        import {
            accountAddress,
            isWalletConnected,
            registerForNetworkChanges,
            registerForWalletChanges
        } from "../../common/wallet/WalletManager";
        import {LimitOrderFactory} from "../../common/order/LimitOrderFactory";
        import {UrlManager} from "../../common/url/UrlManager";
        import {Order} from "../../common/order/Order";
        import {OrderStateManager} from "../../common/order/OrderStateManager";
        import {
            chainToken,
            isConnectedToEthereumMainNet,
            isSupportedNetwork,
            wrappedChainToken
        } from "../../common/ChainHelpers";

        export default {
            components: {
                OrderForm,
                OrderBook,
                OrderList,
                TradeList
            },
            state: {
                orderFactory: null,
                urlManager: new UrlManager()
            },
            onBeforeMount() {
                registerForTokenListUpdate(this)
                registerForWalletChanges(this)
                registerForNetworkChanges(this)
            },
            async onTokenListUpdate() {
                await this.setDefaultFactory()

                this.props.urlManager.updateUrl(this.state.orderFactory.order.sellToken, this.state.orderFactory.order.buyToken)
                await this.state.orderFactory.refreshOrderState()
                this.state.orderFactory.order.observeTokenChanges(this, 'refreshUrl')

                this.update()
            },
            onWalletChanges() {
                if (this.state.orderFactory !== null) {
                    if (isWalletConnected()) {
                        this.state.orderFactory.setAccount(accountAddress())
                    } else {
                        this.state.orderFactory.reset()
                    }
                }
            },
            async onNetworkChanges() {
                if (isSupportedNetwork()) {
                    let sellToken = UrlManager.defaultSellToken()
                    let buyToken = UrlManager.defaultBuyToken()
                    this.props.urlManager.updateUrl(sellToken, buyToken)

                    location.reload()
                }
            },
            refreshUrl() {
                this.props.urlManager.updateUrl(
                    this.state.orderFactory.order.sellToken,
                    this.state.orderFactory.order.buyToken
                )
            },
            setMarketOrderType() {
                this.state.orderFactory = new SwapOrderFactory(
                    this.state.orderFactory.order,
                    this.state.orderFactory.stateManager,
                    accountAddress()
                )
                this.state.orderFactory.order.type = Order.MarketOrderType
                this.state.orderFactory.clearValues()
                this.update()
            },
            setLimitOrderType() {
                this.state.orderFactory = new LimitOrderFactory(
                    this.state.orderFactory.order,
                    this.state.orderFactory.stateManager,
                    accountAddress()
                )
                this.switchToWrappedTokenIfNeeded()
                this.state.orderFactory.order.type = Order.LimitOrderType
                this.state.orderFactory.clearValues()
                this.update()
            },
            async setDefaultFactory() {
                let sellToken = await this.props.urlManager.urlSellToken()
                let buyToken = await this.props.urlManager.urlBuyToken()

                if (isConnectedToEthereumMainNet()) {
                    this.state.orderFactory =
                        new LimitOrderFactory(
                            new Order(
                                Order.LimitOrderType,
                                sellToken,
                                buyToken
                            ),
                            new OrderStateManager(),
                            accountAddress()
                        )
                    this.switchToWrappedTokenIfNeeded()
                } else {
                    this.state.orderFactory =
                        new SwapOrderFactory(
                            new Order(
                                Order.MarketOrderType,
                                sellToken,
                                buyToken
                            ),
                            new OrderStateManager(),
                            accountAddress()
                        )
                }
            },
            switchToWrappedTokenIfNeeded() {
                let token = chainToken()
                if (this.state.orderFactory.order.buyToken.symbol === token.symbol) {
                    this.state.orderFactory.order.setTokens(this.state.orderFactory.order.sellToken, wrappedChainToken())
                    this.refreshUrl()
                }
                if (this.state.orderFactory.order.sellToken.symbol === token.symbol) {
                    this.state.orderFactory.order.setTokens(wrappedChainToken(), this.state.orderFactory.order.buyToken)
                    this.refreshUrl()
                }
            }
        }

    </script>

</order-dashboard>
