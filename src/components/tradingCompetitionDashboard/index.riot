<trading-competition-dashboard>

    <div class="competition-dashboard">

        <div class="activity-period">
            Competition is open from April 19th 2021 until April 28th 2021
        </div>

        <div class="competition-trade-form card">

            <div if={ !this.isConnectedToEthereumMainNet() }>
                <h1>SWITCH TO ETHEREUM MAINNET NETWORK</h1>
            </div>

            <order-form
                    if={ this.isConnectedToEthereumMainNet() }
                    order-factory={ state.orderFactory }
                    set-market-order-type={ setMarketOrderType }
                    set-limit-order-type={ setLimitOrderType }
                    enable-hiding-game={ false }
            />
        </div>

        <div class="competition-largest-trades">
            <largest-trades fills-proxy={ state.fillsProxy }/>
        </div>

        <div class="competition-trade-volumes card">
            <trade-volumes fills-proxy={ state.fillsProxy }/>
        </div>

        <div class="competition-top-daily-trade-volumes card">
            <top-daily-traders fills-proxy={ state.fillsProxy }/>
        </div>

        <div class="trades-details card">
            <trades-details fills-proxy={ state.fillsProxy } />
        </div>

        <div class="competition-prizes">
            <div class="card">
                <h1>Overall Winners</h1>
                <p>
                    Ranked by Trading Volume over entire period
                </p>
                <ul>
                    <li>1st 1000 METRIC + 1000 DAI</li>
                    <li>2nd 500 METRIC + 500 DAI</li>
                    <li>3rd 300 METRIC + 300DAI</li>
                    <li>4th 200 METRIC + 200 DAI</li>
                    <li>5-15th 200 METRIC</li>
                    <li>16-25th 100 METRIC</li>
                </ul>
            </div>
            <div class="card">
                <h1>Extra Prizes</h1>
                <ul>
                    <li>Largest Individual Trade (500 METRIC)</li>
                    <li>Most Trades (500 METRIC)</li>
                    <li>Largest Individual Metric Trade (500 METRIC)</li>
                </ul>
            </div>
            <div class="card">
                <h1>Daily Winners</h1>
                <p>Largest Volume (200 METRIC)</p>
            </div>
        </div>

        <div class="competition-terms card">
            <h1>Terms & Conditions</h1>
            <p>
                Users must make a trade of any two tokens through the metric.exchange interface,
                including making or taking an order or by using the swap facility.
                The trading amount will be converted to equivalent USD value
                at the time of trade for the purposes of calculation.
                It is not essential to hold any METRIC in your wallet to be included in the competition,
                but holding the requisite amount will get the users discounted trading fees as per the revised fee schedule.
            </p>
        </div>

    </div>

    <script>

        import './index.css'
        import OrderForm from '../orderForm/index.riot'
        import TradeVolumes from '../tradeVolumes/index.riot'
        import TopDailyTraders from '../topDailyTraders/index.riot'
        import LargestTrades from '../largestTrades/index.riot'
        import TradesDetails from '../tradesDetails/index.riot'
        import {clearTokenList, registerForTokenListUpdate, resetTokenList} from "../../common/tokens/token_fetch";
        import {SwapOrderFactory} from "../../common/order/SwapOrderFactory";
        import {
            accountAddress, initWeb3,
            isWalletConnected,
            registerForNetworkChanges,
            registerForWalletChanges
        } from "../../common/wallet/WalletManager";
        import {LimitOrderFactory} from "../../common/order/LimitOrderFactory";
        import {Order} from "../../common/order/Order";
        import {OrderStateManager} from "../../common/order/OrderStateManager";
        import {
            chainToken,
            isConnectedToEthereumMainNet,
            wrappedChainToken
        } from "../../common/ChainHelpers";
        import {MetricTrackerFillsProxy} from "../../common/0x/fill/MetricTrackerFillsProxy";
        import {UrlManager} from "../../common/url/UrlManager";
        import moment from "moment/moment";

        export default {
            components: {
                OrderForm,
                TradeVolumes,
                TopDailyTraders,
                LargestTrades,
                TradesDetails
            },
            state: {
                fillsProxy: new MetricTrackerFillsProxy(10, moment('2021-04-28')),
                orderFactory: null
            },
            onBeforeMount() {
                this.props.urlManager.setBase("compete")
                registerForTokenListUpdate(this)
                registerForWalletChanges(this)
                registerForNetworkChanges(this)
            },
            onMounted() {
                initWeb3().then(resetTokenList)
                this.state.fillsProxy.fetchFills()
                this.state.fillsProxy.refreshFills()
            },
            onBeforeUnmount() {
                if (this.state.fillsProxy) {
                    this.state.fillsProxy.clear()
                }
            },
            onUnmounted() {
                clearTokenList()
            },
            async onTokenListUpdate() {
                let sellToken = await this.props.urlManager.urlSellToken()
                let buyToken = await this.props.urlManager.urlBuyToken()

                this.state.orderFactory =
                    new LimitOrderFactory(
                        new Order(
                            Order.LimitOrderType,
                            sellToken,
                            buyToken
                        ),
                        new OrderStateManager(),
                        accountAddress()
                    )
                this.switchToWrappedTokenIfNeeded()
                this.props.urlManager.updateUrl(this.state.orderFactory.order.sellToken, this.state.orderFactory.order.buyToken)
                await this.state.orderFactory.refreshOrderState()
                this.state.orderFactory.order.observeTokenChanges(this, 'refreshUrl')

                this.update()
            },
            onWalletChanges() {
                if (this.state.orderFactory !== null) {
                    if (isWalletConnected()) {
                        this.state.orderFactory.setAccount(accountAddress())
                    } else {
                        this.state.orderFactory.reset()
                    }
                }
                this.update()
            },
            async onNetworkChanges() {
                if (isConnectedToEthereumMainNet()) {
                    let sellToken = UrlManager.defaultSellToken()
                    let buyToken = UrlManager.defaultBuyToken()
                    this.props.urlManager.updateUrl(sellToken, buyToken)

                    location.reload()
                }
            },
            refreshUrl() {
                this.props.urlManager.updateUrl(
                    this.state.orderFactory.order.sellToken,
                    this.state.orderFactory.order.buyToken
                )
            },
            setMarketOrderType() {
                this.state.orderFactory = new SwapOrderFactory(
                    this.state.orderFactory.order,
                    this.state.orderFactory.stateManager,
                    accountAddress()
                )
                this.state.orderFactory.order.type = Order.MarketOrderType
                this.state.orderFactory.clearValues()
                this.update()
            },
            setLimitOrderType() {
                this.state.orderFactory = new LimitOrderFactory(
                    this.state.orderFactory.order,
                    this.state.orderFactory.stateManager,
                    accountAddress()
                )
                this.switchToWrappedTokenIfNeeded()
                this.state.orderFactory.order.type = Order.LimitOrderType
                this.state.orderFactory.clearValues()
                this.update()
            },
            switchToWrappedTokenIfNeeded() {
                let token = chainToken()
                if (this.state.orderFactory.order.buyToken.symbol === token.symbol) {
                    this.state.orderFactory.order.setTokens(this.state.orderFactory.order.sellToken, wrappedChainToken())
                    this.refreshUrl()
                }
                if (this.state.orderFactory.order.sellToken.symbol === token.symbol) {
                    this.state.orderFactory.order.setTokens(wrappedChainToken(), this.state.orderFactory.order.buyToken)
                    this.refreshUrl()
                }
            }
        }

    </script>

</trading-competition-dashboard>
