<order-form>
    <div class="order-form-loader" if={ state.isLoadingTokens }>
        <loader/>
    </div>
    <div id="order-form" if={ !state.isLoadingTokens }>
    
        <div class="order-line order-inputs">
            <div class="token-selector button clickable" onclick={ openInputTokenSelector }>
                { state.inputToken.symbol } ˅
            </div>
            <div class="order-switch-button-image" onclick={ switchDirection } ontouchstart=""></div>
            <div class="token-selector button clickable" onclick={ openOutputTokenSelector }>
                { state.outputToken.symbol } ˅
            </div>
        </div>

        <div class="order-line order-param-values">
            <div>{ this.i18next.t('order.price') }</div>
        </div>
        <div class="order-line exchange-price">
            <div class="order-input">
                <input id="order-price-input" type="number" onkeyup={ updatePrice } placeholder="0"/>
                <label if={!props.isPriceDirectionReverted}>{ this.i18next.t('order.price_direction', {base: state.outputToken, quote: state.inputToken}) }</label>
                <label if={props.isPriceDirectionReverted}>{ this.i18next.t('order.price_direction', {base: state.inputToken, quote: state.outputToken}) }</label>
            </div>
            <div class="order-input">
                <div class="price-switch-button" onclick={ changePriceDirection } ontouchstart=""></div>
            </div>
        </div>

        <div class="order-line order-param-values">
            <div>{ this.i18next.t('order.amount_simple') }</div>
        </div>
        <div class="order-line exchange-price">
            <div class="order-input">
                <input type="number" id="order-amount-input" onkeyup={ updateAmount } placeholder="0"/>
                <label class="label-amount">{ state.inputToken.symbol }</label>
            </div>
            <div class="order-input">
                <div class="max-amount" onclick={ setMaxInputAmount }>{ this.i18next.t('order.max_amount') }</div>
            </div>
        </div>

        <div class="order-line order-info">
            <div>{ this.i18next.t('order.fee') }</div>
            <label>{ formattedFeeAmount() } { sentToken().symbol }</label>
        </div>

        <div class="order-line order-info">
            <div>{ this.i18next.t('order.you_pay') }</div>
            <label>{ formatSentAmount() } { sentToken().symbol }</label>
        </div>

        <div class="order-line order-info">
            <div>{ this.i18next.t('order.you_get') }</div>
            <label>{ formattedTotalAmount() } { receivedToken().symbol }</label>
        </div>

        <div id ="place-order-button" class="order-line button">
            { this.i18next.t(state.submitMessage, state.submitMessageParams) }
        </div>

        <div id="token-selector-box" style="display:none" }>
            <token-selector
                    closeTokenSelector={ closeTokenSelector }
                    selectToken={ selectToken }
            />
        </div>
    </div>

    <script>

        import './order_form.css'
        import TokenSelector from '../../token_selector/token_selector.riot'
        import Loader from '../../loader/loader.riot'
        import {
            registerForTokenAllowancesUpdate,
            registerForTokenBalancesUpdate, registerForTokenListUpdate,
            tokensList
        } from "../../../common/tokens/token_fetch";
        import {
            setBaseToken,
            setQuoteToken
        } from "../../../common/0x/0x_order_book_proxy";
        import {ZeroXOrdersProxy} from "../../../common/0x/0x_orders_proxy";
        import { BigNumber } from '@0x/utils';
        import {calculateMetricFee, MetricReferralAddress} from "../../../common/metric_fee";
        import { router } from '@riotjs/route'
        import {registerForOrderPriceUpdates} from "../../../common/prices/OrderPriceManager";

        export default {
            components: {
                TokenSelector,
                Loader
            },
            state: {
                inputToken: null,
                outputToken: null,
                amount: NaN,
                price: NaN,
                isOutputTokenApproved: false,
                isInputTokenApproved: false,
                showTokenSelector: false,
                isLoadingTokens: true
            },
            onBeforeMount() {
                this.updateTokens()
                this.setOrderMessage()
                router.push(`/#/${this.state.inputToken.address}/${this.state.outputToken.address}`)
            },
            async onMounted() {
                registerForTokenAllowancesUpdate(this)
                registerForTokenBalancesUpdate(this)
                registerForOrderPriceUpdates(this)

                if (!this.state.isLoadingTokens) {
                    await this.refreshOrderMessage()
                }
            },
            changePriceDirection() {
                this.switchPrice(this.state.price)
                this.props.togglePriceDirection()
            },
            switchDirection() {
                let input = this.state.inputToken
                let output = this.state.outputToken

                setBaseToken(output)
                setQuoteToken(input)

                this.state.inputToken = output
                this.state.outputToken = input
                this.resetInputAmount(null)
            },
            updateTokens() {
                if (this.props.inputTokenAddress !== undefined && this.props.inputTokenAddress !== null) {

                    let tokenFromRoute =
                        tokensList().find(t => t.address.toLowerCase() === this.props.inputTokenAddress.toLowerCase())

                    if (tokenFromRoute !== undefined && tokenFromRoute !== null) {
                        this.state.inputToken = tokenFromRoute
                        setBaseToken(this.state.inputToken)
                    }
                }

                if (this.props.outputTokenAddress !== undefined && this.props.outputTokenAddress !== null) {
                    let tokenFromRoute =
                        tokensList().find(t => t.address.toLowerCase() === this.props.outputTokenAddress.toLowerCase())

                    if (tokenFromRoute !== undefined && tokenFromRoute !== null) {
                        this.state.outputToken = tokenFromRoute
                        setQuoteToken(this.state.outputToken)
                    }
                }
                if (this.state.inputToken !== null && this.state.outputToken !== null) {
                    this.state.isLoadingTokens = false
                }
            },
            onOrderPriceUpdate(price) {
                if (this.props.isPriceDirectionReverted) {
                    this.switchPrice(price)
                } else {
                    this.setPrice(price)
                }
                this.updateSubmitButtonState()
                this.refreshOrderMessage()
            },
            switchPrice(price) {
                let newPrice = price
                if (price > 0) {
                    newPrice = 1 / price
                }
                this.setPrice(newPrice)
            },
            setPrice(price) {
                this.state.price = price
                document.getElementById("order-price-input").value = price
            },
            listenToSelectorCloseClick(e) {
                if(this.state.showTokenSelector) {
                    let selector = document.getElementById('token-selector-box');
                    let formSelector = document.getElementById('order-form');

                    if (selector !== null && !selector.contains(e.target) &&
                        formSelector !== null && !formSelector.contains(e.target)) {
                        this.closeTokenSelector();
                    }
                }
            },
            onTokenAllowancesUpdate() {
                this.refreshOrderMessage()
            },
            onTokenBalancesUpdate() {
                this.refreshOrderMessage()
            },
            closeTokenSelector() {
                this.state.showTokenSelector = false
                document.getElementById("token-selector-box").style.display = "none"
                document.removeEventListener('click', this.listenToSelectorCloseClick)
            },
            openInputTokenSelector() {
                this.state.selectionType = "input"
                this.openTokenSelector()
            },
            openOutputTokenSelector() {
                this.state.selectionType = "output"
                this.openTokenSelector()
            },
            openTokenSelector() {
                document.addEventListener('click', this.listenToSelectorCloseClick)
                document.getElementById("token-selector-box").style.display = "block"
                document.getElementById("token-selector-input-text").focus()
                this.state.showTokenSelector = true
            },
            async selectToken(token) {
                if (this.state.selectionType === "input") {
                    await setBaseToken(token)
                    this.state.inputToken = token
                } else {
                    await setQuoteToken(token)
                    this.state.outputToken = token
                }

                router.push(`/#/${this.state.inputToken.address}/${this.state.outputToken.address}`)

                this.refreshOrderMessage()

                this.closeTokenSelector()
            },
            updateAmount(e) {
                this.update({ amount: parseFloat(e.target.value) })
                this.updateSubmitButtonState()
                this.refreshOrderMessage()
            },
            updatePrice(e) {
                this.update({ price: parseFloat(e.target.value) })
                this.updateSubmitButtonState()
                this.refreshOrderMessage()
            },
            updateSubmitButtonState() {
                let button = document.getElementById("place-order-button")
                if (!this.isValidOrder() || !this.isSufficientBalance()) {
                    button.classList.remove("active-button")
                    button.classList.remove("clickable")
                    button.onclick = null
                } else if (this.isValidOrder() && !button.classList.contains("active-button")) {
                    button.classList.add("active-button")
                    button.classList.add("clickable")
                    button.onclick = this.checkApprovalAndSubmitOrder
                }
            },
            async setBuyOrderTypeAndRefresh() {
                await this.setBuyOrderType()
                this.refreshOrderMessage()
            },
            async setBuyOrderType() {
                this.updateSubmitButtonState()
                this.removeInputAmountClickableState()
            },
            async setSellOrderTypeAndRefresh() {
                this.updateSubmitButtonState()
                this.refreshOrderMessage()
                this.addInputAmountClickableState()
            },
            addInputAmountClickableState() {
                let element = document.getElementById("input-balance-amount")
                element.classList.add("clickable")
                element.onclick = this.setMaxInputAmount
            },
            removeInputAmountClickableState() {
                let element = document.getElementById("input-balance-amount")
                element.classList.remove("clickable")
                element.onclick = null
            },
            setMaxInputAmount() {
                this.resetInputAmount(this.state.inputToken.balance)
            },
            resetInputAmount(amount) {
                this.update({ amount: amount })
                this.updateSubmitButtonState()
                this.refreshOrderMessage()
                document.getElementById("order-amount-input").value = amount
            },
            async checkApprovalAndSubmitOrder() {
                if (await this.isApproved()) {
                    await this.sendOrder()
                } else {
                    await this.requestApprovalAndSubmitOrder()
                }
                this.refreshOrderMessage()
            },
            async requestApprovalAndSubmitOrder() {
                await this.sendApprovalForTokenAndSubmitOrder(this.state.inputToken)
            },
            async sendApprovalForTokenAndSubmitOrder(token) {
                this.setApprovalMessage(token)
                await ZeroXOrdersProxy.approveZeroXAllowance(
                    token.address,
                    (a, b) => {
                        this.refreshOrderMessage()
                    },
                    (e) => {
                        this.refreshOrderMessage()
                    }
                )
            },
            async sendOrder() {
                await ZeroXOrdersProxy.submitOrder(
                    this.buildOrder(),
                    MetricReferralAddress,
                    calculateMetricFee()
                )
            },
            buildOrder() {
                let inputAmount = this.inputAmount() * (10 ** this.state.inputToken.decimals)
                let outputAmount = this.outputAmount() * (10 ** this.state.outputToken.decimals)

                return {
                    makerAssetAmount: new BigNumber(inputAmount),
                    makerAssetAddress: this.state.inputToken.address,
                    takerAssetAmount: new BigNumber(outputAmount),
                    takerAssetAddress: this.state.outputToken.address
                }
            },
            inputAmount() {
                return this.state.amount
            },
            outputAmount() {
                let amount = this.inputAmount()
                return (isNaN(amount) ? 0 : amount) * this.orderPrice()
            },
            orderPrice() {
                let price = (isNaN(this.state.price) || this.state.price == null) ? 0 : this.state.price

                if (price > 0 && this.props.isPriceDirectionReverted) {
                    return 1 / price
                } else {
                    return price
                }
            },
            sentAmount() {
                let amount = this.inputAmount()
                return (isNaN(amount) || amount == null) ? 0 : amount
            },
            receivedAmount() {
                let amount = this.outputAmount()
                return (isNaN(amount) || amount == null) ? 0 : amount
            },
            receivedToken() {
                return this.state.outputToken
            },
            sentToken() {
                return this.state.inputToken
            },
            formattedTotalAmount() {
                return ((this.receivedAmount() - this.applyFee(this.receivedAmount()))).toFixed(3)
            },
            formatSentAmount() {
                return this.sentAmount().toFixed(3)
            },
            formattedFeeAmount() {
                return this.applyFee(this.sentAmount()).toFixed(3)
            },
            applyFee(amount) {
                return amount * calculateMetricFee()
            },
            async isApproved() {
                return await ZeroXOrdersProxy.is0xApprovedForToken(this.state.inputToken.address, this.inputAmount() * (10 ** this.state.inputToken.decimals))
            },
            setApprovalMessage(token) {
                this.update({
                    submitMessage: "submit.approving",
                    submitMessageParams: {token: token}
                })
            },
            setOrderMessage() {
                if (!this.isValidInputs()) {
                    this.state.submitMessage = "submit.place_order"
                    this.state.submitMessageParams = {}
                } else if (!this.isValidOrder()) {
                    this.state.submitMessage = "submit.must_be_greater_than"
                    this.state.submitMessageParams = {token: this.state.outputToken}
                } else if (!this.isSufficientBalance()) {
                    this.state.submitMessage = "submit.insufficient_balance"
                    this.state.submitMessageParams = {}
                } else if(!this.maybeIsApproved()) {
                    this.state.submitMessage = "submit.approve"
                    this.state.submitMessageParams = {token: this.state.inputToken}
                } else {
                    this.state.submitMessage = "submit.place_order"
                    this.state.submitMessageParams = {}
                }
            },
            refreshOrderMessage() {
                this.setOrderMessage()
                this.update()
            },
            maybeIsApproved() {
                return tokensList().find(t => t.symbol === this.state.inputToken.symbol).allowance >= this.inputAmount()
            },
            isValidOrder() {
                let isAmountAboveThreshold = (this.outputAmount() > this.state.outputToken.volume_limit)
                return this.isValidInputs() && isAmountAboveThreshold
            },
            isValidInputs() {
                return !isNaN(this.state.price) &&
                    !isNaN(this.state.amount) &&
                    this.state.amount > 0 &&
                    this.state.price > 0
            },
            isSufficientBalance() {
                let balance = tokensList().find(t => t.symbol === this.state.inputToken.symbol).balance
                let amount = this.inputAmount()

                return balance >= amount
            },
            formatWalletBalance(amount) {
                return new BigNumber(amount).toFixed(3, BigNumber.ROUND_DOWN)
            }
        }

    </script>

</order-form>
