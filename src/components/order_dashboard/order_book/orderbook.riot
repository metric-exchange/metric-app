<order-book>
    <div class="order-book-body">
        <div class="order-book-title">{ this.i18next.t('order_book.title') }</div>
        <div class="order-book-content">
            <loader if={ state.isLoadingOrders }/>
            <div class="order-book-columns orders-header" if={ !state.isLoadingOrders }>
                <div>{ this.i18next.t('order.amount', { token: state.inputToken }) }</div>
                <div>{ this.i18next.t('order.price', { token: priceToken() }) }</div>
                <div>{ this.i18next.t('order.total', { token: state.outputToken }) }</div>
            </div>
            <div id="order-table-canvas" onscroll={ disableScrollToView } if={ !state.isLoadingOrders }>
                <div each={ask in state.asks} class="order order-book-columns" onclick={ (e) => setOrderPrice(ask.price) }>
                    <div class="ask">{ ask.volumeTaker.toFixed(config.displayedDecimalPoints) }</div>
                    <div class="order-price">{ ask.price }</div>
                    <div class="bid">{ ask.volumeMaker.toFixed(config.displayedDecimalPoints) }</div>
                </div>
                <div id="orders-separator" class="order-book-columns" onclick={ (e) => setOrderPrice(state.midMarketPrice) }>
                    <div/>
                    <div>{ state.midMarketPrice }</div>
                    <div/>
                </div>
                <div each={bid in state.bids} class="order order-book-columns" onclick={ (e) => setOrderPrice(bid.price) }>
                    <div class="bid">{ bid.volumeTaker.toFixed(config.displayedDecimalPoints) }</div>
                    <div class="order-price">{ bid.price }</div>
                    <div class="ask">{ bid.volumeMaker.toFixed(config.displayedDecimalPoints) }</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        import './orderbook.css'
        import Loader from '../../loader/loader.riot'

        import {
            getBaseToken,
            getOrderBookAsks,
            getOrderBookBids, getQuoteToken, registerForBaseTokenChange,
            registerForOrderBookUpdateEvents
        } from "../../../common/0x/0x_order_book_proxy";

        import {BigNumber} from '@0x/utils';
        import {getTokenUsdPrice} from "../../../common/tokens/token_price_proxy";
        import {updateOrderPrice} from "../../../common/prices/OrderPriceManager";

        export default {
            components: {
                Loader
            },
            config: {
                displayedDecimalPoints: 3
            },
            state: {
                asks: [],
                bids: [],
                midMarketPrice: null,
                triggerScrollToView: true,
                oldPriceDirectionState: false,
                isLoadingOrders: true
            },
            onBeforeMount() {
                this.state.inputToken = getBaseToken()
                this.state.outputToken = getQuoteToken()
            },
            onMounted() {
                registerForBaseTokenChange(this)
                registerForOrderBookUpdateEvents(this)
            },
            onBaseTokenUpdate() {
                this.update({
                    isLoadingOrders: true
                });
            },
            async onOrderBookUpdate() {
                this.state.inputToken = getBaseToken()
                this.state.outputToken = getQuoteToken()

                await this.fetchOrderBook(this.state.inputToken, this.state.outputToken)
            },
            onBeforeUpdate() {
                if (this.oldPriceDirectionState !== this.props.isPriceDirectionReverted) {
                    this.isLoadingOrders = true
                }
            },
            async onUpdated() {
                if (this.oldPriceDirectionState !== this.props.isPriceDirectionReverted) {
                    this.oldPriceDirectionState = this.props.isPriceDirectionReverted
                    this.isLoadingOrders = true
                    await this.fetchOrderBook(this.state.inputToken, this.state.outputToken)
                }
                if (this.state.triggerScrollToView && !this.state.isLoadingOrders) {
                    this.scrollOrderBookIntoView()
                }
            },
            disableScrollToView() {
                this.state.triggerScrollToView = false
            },
            async fetchOrderBook(inputToken, outputToken) {
                if (inputToken !== null && outputToken !== null) {

                    let asks =
                        getOrderBookAsks().map(b => {

                            let makerAmount = b.order.makerAssetAmount.dividedBy(10 ** inputToken.decimals)
                            let takerAmount = b.order.takerAssetAmount.dividedBy(10 ** outputToken.decimals)
                            let remainingTakerAmount = new BigNumber(parseInt(b.metaData.remainingFillableTakerAssetAmount)).dividedBy(10 ** outputToken.decimals)
                            let remainingMakerAmount = makerAmount.multipliedBy(remainingTakerAmount).dividedBy(takerAmount)

                            return {
                                price: this.calculatePrice(takerAmount, makerAmount, BigNumber.ROUND_UP),
                                volumeMaker: remainingTakerAmount,
                                volumeTaker: remainingMakerAmount
                            }
                        })

                    let bids =
                        getOrderBookBids().map(b => {

                            let makerAmount = b.order.makerAssetAmount.dividedBy(10 ** outputToken.decimals)
                            let takerAmount = b.order.takerAssetAmount.dividedBy(10 ** inputToken.decimals)
                            let remainingTakerAmount = new BigNumber(parseInt(b.metaData.remainingFillableTakerAssetAmount)).dividedBy(10 ** inputToken.decimals)
                            let remainingMakerAmount = makerAmount.multipliedBy(remainingTakerAmount).dividedBy(takerAmount)

                            return {
                                price: this.calculatePrice(makerAmount, takerAmount, BigNumber.ROUND_DOWN),
                                volumeMaker: remainingMakerAmount,
                                volumeTaker: remainingTakerAmount
                            }
                        })

                    Array.prototype.sumByPrice = function() {
                        return Object.values(this.reduce(function(groups, item) {
                            const key = item.price
                            groups[key] = groups[key] || {price: key, volumeMaker: 0, volumeTaker: 0}
                            groups[key] = {
                                price:key,
                                volumeMaker: item.volumeMaker.plus(groups[key].volumeMaker),
                                volumeTaker: item.volumeTaker.plus(groups[key].volumeTaker)
                            }
                            return groups
                        }, {}))
                    }

                    this.state.bids =
                        bids
                            .sumByPrice()
                            .sort((a, b) => parseFloat(b.price) - parseFloat(a.price))

                    this.state.asks =
                        asks
                            .sumByPrice()
                            .sort((a, b) => parseFloat(b.price) - parseFloat(a.price))

                    this.state.midMarketPrice = await this.midMarketPrice()
                    await this.update({
                        isLoadingOrders: false,
                        triggerScrollToView: true
                    })

                }
            },

            calculatePrice(quote, base, rounding) {
                if (!this.props.isPriceDirectionReverted) {
                    return quote.dividedBy(base).toFixed(this.config.displayedDecimalPoints, rounding)
                } else {
                    return base.dividedBy(quote).toFixed(this.config.displayedDecimalPoints, 1 - rounding)
                }
            },

            async midMarketPrice() {
                if (this.state.asks.length > 0 && this.state.bids.length > 0) {
                    let bestAsk = this.state.asks.slice(-1)[0]
                    let bestBid = this.state.bids[0]

                    return ((parseFloat(bestAsk.price) + parseFloat(bestBid.price)) / 2).toFixed(this.config.displayedDecimalPoints)
                } else {
                    let baseTokenUsdPrice = await getTokenUsdPrice(this.state.inputToken.address, this.state.inputToken.symbol)
                    let quoteTokenUsdPrice = await getTokenUsdPrice(this.state.outputToken.address, this.state.outputToken.symbol)

                    if (baseTokenUsdPrice > 0 && quoteTokenUsdPrice > 0) {
                        return this.formatPrice((baseTokenUsdPrice / quoteTokenUsdPrice).toFixed(this.config.displayedDecimalPoints))
                    } else {
                        return null
                    }
                }
            },
            scrollOrderBookIntoView() {
                let canvas = document.getElementById("order-table-canvas")
                let separator = document.getElementById("orders-separator")
                if (canvas !== null && separator !== null && this.isInViewport(canvas)) {
                    separator.scrollIntoView({behavior: "smooth", block: "center"});
                }
            },
            isInViewport(element) {
                let rect = element.getBoundingClientRect();
                return (
                    rect.top >= 0 &&
                    rect.left >= 0 &&
                    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                    rect.right <= (window.innerWidth || document.documentElement.clientWidth)
                )
            },
            setOrderPrice(price) {
                updateOrderPrice(parseFloat(price))
            },
            formatPrice(price) {
                let formattedPrice = parseFloat(price)
                if (this.props.isPriceDirectionReverted) {
                    formattedPrice = price > 0 ? 1 / price : 0
                }

                return formattedPrice.toFixed(this.config.displayedDecimalPoints)
            },
            priceToken() {
                if (this.props.isPriceDirectionReverted) {
                    return this.state.inputToken
                } else {
                    return this.state.outputToken
                }
            }
        }

    </script>
</order-book>
