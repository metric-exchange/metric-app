<order-form>
    <div class="order-form-loader" if={ state.isLoadingTokens }>
        <loader inverted={ false } />
    </div>

    <div id="order-form" if={ !state.isLoadingTokens }>

        <div class="order-line exchange-price">
            <div class="order-input">
                <div class="input-sticky-placeholder" if={ !isNaN(state.inputAmount) }>
                    { this.i18next.t('order.you_pay') } { this.i18next.t('order.with_fee', {amount: formattedFeeAmount()}) }
                </div>
                <input type="number" id="order-amount-input" onkeyup={ updateInputAmount } placeholder="{ this.i18next.t('order.you_pay') }"/>
                <label class="label-amount" onclick={ openInputTokenSelector }>{ state.inputToken.symbol } ˅</label>
            </div>
            <div class="order-input">
                <div if={ isTokenInfoUpdated() } class="max-amount" onclick={ setMaxInputAmount }>{ this.i18next.t('order.max_amount') }</div>
                <div class="max-amount-loader" if={ !isTokenInfoUpdated() } >
                    <loader inverted={ false } />
                </div>
            </div>
        </div>

        <div class="order-line exchange-price">
            <div class="order-input">
                <div class="input-sticky-placeholder" if={ !isNaN(state.outputAmount) }>{ this.i18next.t('order.you_get') }</div>
                <input type="number" id="order-amount-output" onkeyup={ updateOutputAmount } placeholder="{ this.i18next.t('order.you_get') }"/>
                <label class="label-amount" onclick={ openOutputTokenSelector }>{ state.outputToken.symbol } ˅</label>
            </div>
            <div class="order-input">
                <div id="order-switch" class="order-line switch-button" onclick={ switchDirection }>
                    <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="15" cy="15" r="15" transform="rotate(-90 15 15)" fill="#262626"/>
                        <path d="M12.5 11V19L11 17.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M17.5 18.9872L17.5 10.9985L19 12.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
            </div>
        </div>

        <div class="order-line exchange-price">
            <div class="order-input">
                <div class="input-sticky-placeholder" if={ !isNaN(state.price) }>{ this.i18next.t('order.price') }</div>
                <input id="order-price-input" type="number" onkeyup={ updatePrice } placeholder="{ this.i18next.t('order.price') }"/>
                <label if={!props.isPriceDirectionReverted}>{ this.i18next.t('order.price_direction', {base: state.outputToken, quote: state.inputToken}) }</label>
                <label if={props.isPriceDirectionReverted}>{ this.i18next.t('order.price_direction', {base: state.inputToken, quote: state.outputToken}) }</label>
            </div>
            <div class="order-input">
                <div id="price-switch" class="switch-button" onclick={ changePriceDirection }>
                    <svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="15" cy="15" r="15" fill="#262626"/>
                        <path d="M18 11L19.5 12.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M19.5 12.5H13C12 12.5 10.5 12.5 10.5 14.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M12 19L10.5 17.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M10.5 17.5L17.0138 17.5C18.0138 17.5 19.5138 17.5 19.5138 15.5" stroke="#888888" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </div>
            </div>
        </div>

        <div></div>

<!--        <div class="order-line order-validity-input">-->
<!--            <div class="order-input order-valid-until-label">-->
<!--                { this.i18next.t('order.valid_until') }-->
<!--            </div>-->
<!--            <div class="order-input">-->
<!--                <input class="date-input" id="order-expiry-date-input"/>-->
<!--            </div>-->
<!--        </div>-->

<!--        <div class="order-line">-->
<!--            <div class="order-input">-->
<!--                <div class="input-sticky-placeholder" if={ isValidNonEmptyRecipientAddress() }>{ this.i18next.t('order.recipient_address_placeholder') }</div>-->
<!--                <input id="order-taker-address-input"-->
<!--                       type="text"-->
<!--                       onkeyup={ updateRecipientAddress }-->
<!--                       placeholder="{ this.i18next.t('order.recipient_address_placeholder') }"-->
<!--                       value={ state.recipientAddress }-->
<!--                />-->
<!--            </div>-->
<!--        </div>-->

        <div id ="place-order-button" class="order-line button">
            <div class="order-submit-loader" if={ state.buttonDisplay.showLoader }>
                <loader inverted={ true } />
            </div>
            <div class={state.buttonDisplay.isError ? "error-message" : ""}>{ this.i18next.t(state.buttonDisplay.message, state.buttonDisplay.params).toUpperCase() }</div>
        </div>

        <div id="token-selector-box" style="display:none" }>
            <token-selector
                    closeTokenSelector={ closeTokenSelector }
                    selectToken={ selectToken }
            />
        </div>
    </div>

    <script>

        import './order_form.css'
        import TokenSelector from '../../token_selector/token_selector.riot'
        import Loader from '../../loader/loader.riot'
        import {
            findOrAddTokenWithAddress,
            registerForTokenAllowancesUpdate,
            registerForTokenBalancesUpdate, registerForTokenListUpdate,
            tokensList
        } from "../../../common/tokens/token_fetch";
        import {
            setBaseToken,
            setQuoteToken
        } from "../../../common/0x/0x_order_book_proxy";
        import {
            approveZeroXAllowance, calculateRemainingOrderDetails,
            findCandidateOrders,
            submitOrder,
            fillOrders
        } from "../../../common/0x/0x_orders_proxy";
        import { BigNumber } from '@0x/utils';
        import {calculateMetricFee, MetricReferralAddress} from "../../../common/metric_fee";
        import { router } from '@riotjs/route'
        import {registerForOrderPriceUpdates} from "../../../common/prices/OrderPriceManager";
        import moment from 'moment';
        import flatpickr from "flatpickr";
        import "./flatpicker.css";
        import {supportedDateTranslations} from "../../../common/localization/localize";
        import {isWalletConnected, registerForWalletChanges} from "../../../common/wallet/wallet_manager";
        import {
            approveToken,
            approving, connectWalletMessage, fillingOrder, insufficientBalance,
            matchingOrder,
            orderFillExecuted,
            placeOrder, submittingOrder
        } from "./order_messages";

        export default {
            components: {
                TokenSelector,
                Loader
            },
            state: {
                inputToken: null,
                outputToken: null,
                inputAmount: NaN,
                outputAmount: NaN,
                price: NaN,
                showTokenSelector: false,
                isLoadingTokens: true,
                expiryTime: moment().add(1, 'years').format("yyyy-MM-DD HH:mm"),
                recipientAddress: null,
                datepicker: undefined,
                orderSubmissionInProgress: false
            },
            onBeforeMount() {
                registerForTokenListUpdate(this)
                registerForTokenAllowancesUpdate(this)
                registerForTokenBalancesUpdate(this)
                registerForOrderPriceUpdates(this)
                registerForWalletChanges(this)

                this.setOrderMessage()
            },
            onUpdated() {
                let dateinput = document.getElementById("order-expiry-date-input")
                let that = this
                if (this.state.datepicker === undefined && dateinput !== null) {
                    this.datepicker = flatpickr(dateinput, {
                        enableTime: true,
                        defaultDate: this.state.expiryTime,
                        altFormat: "F j, Y H:i K",
                        altInput: true,
                        dateFormat: "Y-m-d H:i",
                        onChange: function(selectedDates, dateStr, instance) {
                            that.state.expiryTime = moment(dateStr).format("yyyy-MM-DD HH:mm")
                        },
                        minDate: moment().format("yyyy-MM-DD"),
                        locale: supportedDateTranslations[this.i18next.language]
                    });
                    this.i18next.on("languageChanged", (lng, ns) => {
                        flatpickr.localize(supportedDateTranslations[lng]);
                    })
                }
            },
            onWalletChanges() {
                if (!isWalletConnected()) {
                    this.resetInputs()
                }
                this.refreshOrderMessage()
            },
            async onTokenListUpdate() {
                console.debug("token list updated")
                await this.updateTokens()
                this.refreshOrderMessage()
            },
            updateRecipientAddress(e) {
                this.update({recipientAddress: e.target.value})
            },
            isValidNonEmptyRecipientAddress() {
                return this.state.recipientAddress !== null &&
                    this.state.recipientAddress.length > 0
            },
            updateExpiryTime(e) {
                this.state.expiryTime = e.target.value
            },
            changePriceDirection(e) {
                this.props.togglePriceDirection()
                document.getElementById("price-switch").classList.toggle("transition-half-rotate")
                if (this.state.price > 0 && this.props.isPriceDirectionReverted) {
                    document.getElementById("order-price-input").value = 1 / this.state.price
                } else {
                    document.getElementById("order-price-input").value = this.state.price
                }
            },
            switchDirection(e) {
                if (this.props.isPriceDirectionReverted) {
                    this.props.togglePriceDirection()
                }

                let input = this.state.inputToken
                let output = this.state.outputToken

                setBaseToken(output)
                setQuoteToken(input)

                this.state.inputToken = output
                this.state.outputToken = input
                this.resetInputAmount(NaN)

                router.push(`/#/${this.state.inputToken.address}/${this.state.outputToken.address}`)

                document.getElementById("order-switch").classList.toggle("transition-half-rotate")

                this.resetInputs()

            },
            async updateTokens() {
                console.debug("updating tokens: ", this.props.inputTokenAddress, this.props.outputTokenAddress)

                if (this.props.inputTokenAddress !== undefined && this.props.inputTokenAddress !== null) {

                    let tokenFromRoute = await findOrAddTokenWithAddress(this.props.inputTokenAddress)

                    if (tokenFromRoute !== undefined && tokenFromRoute !== null) {
                        console.log("input token found", tokenFromRoute)
                        this.state.inputToken = tokenFromRoute
                        setBaseToken(this.state.inputToken)
                    }
                }

                if (this.props.outputTokenAddress !== undefined && this.props.outputTokenAddress !== null) {
                    let tokenFromRoute = await findOrAddTokenWithAddress(this.props.outputTokenAddress)

                    if (tokenFromRoute !== undefined && tokenFromRoute !== null) {
                        console.log("output token found", tokenFromRoute)
                        this.state.outputToken = tokenFromRoute
                        setQuoteToken(this.state.outputToken)
                    }
                }

                if (this.state.inputToken !== null && this.state.outputToken !== null) {
                    this.state.isLoadingTokens = false
                    router.push(`/#/${this.state.inputToken.address}/${this.state.outputToken.address}`)
                }
            },
            onOrderPriceUpdate(price) {
                this.setPrice(price)
                this.refreshOrderMessage()
            },
            setPrice(price) {
                let element = document.getElementById("order-price-input")
                if (element !== null) {
                    if (this.props.isPriceDirectionReverted && this.state.price > 0 ) {
                        this.state.price = 1 / price
                    } else {
                        this.state.price = price
                    }
                    element.value = price
                    let amount = this.state.price * this.state.inputAmount
                    if (!isNaN(amount)) {
                        this.resetOutputAmount(amount - this.applyFee(amount), true, false)
                    }
                }
            },
            listenToSelectorCloseClick(e) {
                if(this.state.showTokenSelector) {
                    let selector = document.getElementById('token-selector-box');
                    let formSelector = document.getElementById('order-form');

                    if (selector !== null && !selector.contains(e.target) &&
                        formSelector !== null && !formSelector.contains(e.target)) {
                        this.closeTokenSelector();
                    }
                }
            },
            onTokenAllowancesUpdate() {
                this.refreshOrderMessage()
            },
            onTokenBalancesUpdate() {
                this.refreshOrderMessage()
            },
            closeTokenSelector() {
                this.state.showTokenSelector = false
                document.getElementById("token-selector-box").style.display = "none"
                document.removeEventListener('click', this.listenToSelectorCloseClick)
            },
            openInputTokenSelector() {
                this.state.selectionType = "input"
                this.openTokenSelector()
            },
            openOutputTokenSelector() {
                this.state.selectionType = "output"
                this.openTokenSelector()
            },
            openTokenSelector() {
                document.addEventListener('click', this.listenToSelectorCloseClick)
                document.getElementById("token-selector-box").style.display = "block"
                document.getElementById("token-selector-input-text").focus()
                this.state.showTokenSelector = true
            },
            async selectToken(token) {
                if (this.state.selectionType === "input") {
                    await setBaseToken(token)
                    this.state.inputToken = token
                } else {
                    await setQuoteToken(token)
                    this.state.outputToken = token
                }
                router.push(`/#/${this.state.inputToken.address}/${this.state.outputToken.address}`)

                this.refreshOrderMessage()
                this.closeTokenSelector()

                this.update()
                this.resetInputs()
            },
            updateInputAmount(e) {
                this.resetInputAmount(parseFloat(e.target.value), false)
            },
            updateOutputAmount(e) {
                this.resetOutputAmount(parseFloat(e.target.value), false)
            },
            updatePrice(e) {
                this.setPrice(parseFloat(e.target.value))
                let amount = this.state.price * this.state.inputAmount
                this.resetOutputAmount(amount - this.applyFee(amount), true, false)
            },
            updateSubmitButtonState() {
                let button = document.getElementById("place-order-button")
                if (button !== null) {
                    if (!isWalletConnected() || !this.isValidInputs() || !this.isSufficientBalance()) {
                        button.classList.remove("active-button")
                        button.classList.remove("clickable")
                        button.onclick = null
                    } else if (this.isValidInputs() && !button.classList.contains("active-button")) {
                        button.classList.add("active-button")
                        button.classList.add("clickable")
                        button.onclick = this.checkApprovalAndSubmitOrder
                    }
                }
            },
            async setMaxInputAmount() {
                if (isWalletConnected()) {
                    this.resetInputAmount(this.state.inputToken.balance)
                } else {
                    await this.connectWallet()
                }
            },
            resetInputAmount(amount, updateField = true) {

                this.state.inputAmount = amount > 0 ? amount : NaN
                if (updateField) {
                    document.getElementById("order-amount-input").value = this.state.inputAmount
                }

                let value = this.state.inputAmount * this.state.price - this.applyFee(this.state.inputAmount * this.state.price)
                this.state.outputAmount = value > 0 ? value : NaN
                document.getElementById("order-amount-output").value = this.state.outputAmount

                this.refreshOrderMessage()
            },
            resetOutputAmount(amount, updateField, updateInputField = true) {

                this.state.outputAmount = amount > 0 ? amount : NaN
                if (updateField) {
                    document.getElementById("order-amount-output").value = this.state.outputAmount
                }

                if (updateInputField) {
                    let inputAmount = 0
                    if (this.state.price > 0 && amount > 0 ) {
                        inputAmount = amount / this.state.price
                    }

                    let value = inputAmount * (1 + calculateMetricFee())
                    this.state.inputAmount = value > 0 ? value : NaN
                    document.getElementById("order-amount-input").value = this.state.inputAmount
                }

                this.refreshOrderMessage()
            },
            async checkApprovalAndSubmitOrder() {
                this.startSubmitProcess()
                if (this.isApproved()) {
                    await this.sendOrder()
                } else {
                    await this.sendApprovalForTokenAndSubmitOrder(this.state.inputToken)
                }
            },
            async sendApprovalForTokenAndSubmitOrder(token) {
                this.update({ buttonDisplay: approving(token) })
                await approveZeroXAllowance(
                    token.address,
                    async (a, b) => {
                        await this.sendOrder()
                    },
                    (e) => {
                        this.stopSubmitProcess(false)
                    }
                )
            },
            async sendOrder() {
                this.update({ buttonDisplay: matchingOrder() })

                let order = this.buildOrder()
                let candidates = await findCandidateOrders(order)

                setTimeout(async () => {
                    if (candidates.length > 0) {
                        await this.matchCandidateOrdersAndSubmitRemaining(order, candidates)
                    } else {
                        await this.submitRemainingOrderAfterFill(order, new BigNumber(0))
                    }
                }, 1000)
            },
            async matchCandidateOrdersAndSubmitRemaining(order, candidates) {
                let filledAmount = await this.fillMatchingOrders(order, candidates)
                if (isNaN(filledAmount)) {
                    this.stopSubmitProcess(false)
                } else if (filledAmount.isLessThan(order.makerAssetAmount)) {

                    this.update({ buttonDisplay: orderFillExecuted(filledAmount.toNumber(), this.state.inputToken) })
                    setTimeout(async () => {
                        await this.submitRemainingOrderAfterFill(order, filledAmount)
                    }, 1000)
                }
            },
            async fillMatchingOrders(order, candidates) {
                let filledAmount = NaN
                try {

                    let fillAmount =
                        candidates
                            .map(o => o.takerFillAmount)
                            .reduce((a, b) => BigNumber.sum(a, b))
                            .dividedBy(10 ** this.state.inputToken.decimals)

                    this.update({ buttonDisplay: fillingOrder(fillAmount.toNumber(), this.state.inputToken) })

                    filledAmount = await fillOrders(candidates)

                } catch (e) {
                    filledAmount = NaN
                    console.warn("Order fill failed", e.message)
                }

                return filledAmount
            },
            async submitRemainingOrderAfterFill(order, filledAmount) {
                let remainingOrder = calculateRemainingOrderDetails(order, filledAmount)
                let remainingAmount =
                    remainingOrder.makerAssetAmount.dividedBy(10 ** this.state.inputToken.decimals)

                this.update({ buttonDisplay: submittingOrder(remainingAmount.toNumber(), this.state.inputToken) })
                try {
                    await submitOrder(
                        remainingOrder,
                        MetricReferralAddress,
                        calculateMetricFee()
                    )

                } catch (e) {
                    console.warn("Order submit rejected")
                }

                this.stopSubmitProcess(false)
            },
            buildOrder() {
                let inputAmount =
                    this.state.inputAmount * (10 ** this.state.inputToken.decimals)
                    - this.applyFee(this.state.inputAmount) * (10 ** this.state.inputToken.decimals)

                let outputAmount = this.state.outputAmount * (10 ** this.state.outputToken.decimals)

                console.debug(`selling: ${this.state.inputAmount - this.applyFee(this.state.inputAmount)} ${this.state.inputToken.symbol}`)
                console.debug(`fee: ${this.applyFee(this.state.inputAmount)} ${this.state.inputToken.symbol}`)
                console.debug(`buying: ${this.state.outputAmount} ${this.state.outputToken.symbol}`)

                let order = {
                    makerAssetAmount: new BigNumber(inputAmount).integerValue(BigNumber.ROUND_DOWN),
                    makerAssetAddress: this.state.inputToken.address,
                    takerAssetAmount: new BigNumber(outputAmount).integerValue(BigNumber.ROUND_DOWN),
                    takerAssetAddress: this.state.outputToken.address,
                    expirationTimeSeconds: moment(this.state.expiryTime).unix(),
                }

                if (this.isValidNonEmptyRecipientAddress()) {
                    order.takerAddress = this.state.recipientAddress
                }

                return order
            },
            formattedFeeAmount() {
                return this.applyFee(this.state.inputAmount).toFixed(3)
            },
            applyFee(amount) {
                let feePercentage = calculateMetricFee()
                return amount * feePercentage / (1 + feePercentage)
            },
            setOrderMessage() {
                if (this.state.orderSubmissionInProgress === false) {
                    if (!isWalletConnected()) {
                        this.state.buttonDisplay = connectWalletMessage()
                    } else if (!this.isValidInputs()) {
                        this.state.buttonDisplay = placeOrder()
                    } else if (!this.isSufficientBalance()) {
                        this.state.buttonDisplay = insufficientBalance()
                    } else if(!this.isApproved()) {
                        this.state.buttonDisplay = approveToken(this.state.inputToken)
                    } else {
                        this.state.buttonDisplay = placeOrder()
                    }
                }
            },
            refreshOrderMessage() {
                this.setOrderMessage()
                this.updateSubmitButtonState()
                this.update()
            },
            isApproved() {
                return tokensList()
                    .find(t => t.address.toLowerCase() === this.state.inputToken.address.toLowerCase())
                    .allowance >= this.state.inputAmount
            },
            isValidInputs() {
                return !isNaN(this.state.price) &&
                    !isNaN(this.state.inputAmount) &&
                    this.state.inputAmount > 0 &&
                    this.state.price > 0
            },
            isSufficientBalance() {
                let balance = tokensList()
                    .find(t => t.address.toLowerCase() === this.state.inputToken.address.toLowerCase())
                    .balance

                let amount = this.state.inputAmount

                return balance >= amount
            },
            formatWalletBalance(amount) {
                return new BigNumber(amount).toFixed(3, BigNumber.ROUND_DOWN)
            },
            startSubmitProcess() {
                this.state.orderSubmissionInProgress = true
            },
            stopSubmitProcess(resetInputs = true) {
                this.state.orderSubmissionInProgress = false
                this.refreshOrderMessage()
                if (resetInputs) {
                    this.resetInputs()
                }
            },
            resetInputs() {
                this.state.recipientAddress = null
                this.state.expiryTime = moment().add(1, 'years').format("yyyy-MM-DDTHH:mm")
                this.setPrice(NaN)
                this.resetInputAmount(NaN)
            },
            isTokenInfoUpdated() {
                return !isWalletConnected() ||
                    (this.state.inputToken !== null && this.state.inputToken.initialized)
            }
        }

    </script>

</order-form>
