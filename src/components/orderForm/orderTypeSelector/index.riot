<order-type-selector>

    <div class="order-type-selector" if={ this.isConnectedToEthereumMainNet() }>
        <div if={ currentOrderType() === config.LIMIT } onclick={ showOrderTypesList } >{ config.LIMIT }</div>
        <div if={ currentOrderType() === config.SWAP } onclick={ showOrderTypesList } >{ config.SWAP }</div>
        <div if={ currentOrderType() === config.HIDING_GAME } onclick={ showOrderTypesList } >{ config.HIDING_GAME }</div>
        <svg width="8" height="10" viewBox="0 0 289 142" fill="none" xmlns="http://www.w3.org/2000/svg" onclick={ showOrderTypesList }>
            <path d="M8 8L147 134L281 8" stroke="black" stroke-width="30" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        <div class="order-types-list" if={ state.showList }>
            <div class="order-type"
                 if={ currentOrderType() !== config.LIMIT }
                 onclick={ setLimitType }
            >
                { config.LIMIT }
            </div>
            <div class="order-type"
                 if={ currentOrderType() !== config.SWAP }
                 onclick={ setSwapType }
            >
                { config.SWAP }
            </div>
            <div class="order-type"
                 if={ currentOrderType() !== config.HIDING_GAME && isOrderSupportedByHidingGame() }
                 onclick={ setHidingGameType }
            >
                { config.HIDING_GAME }
            </div>
        </div>
    </div>

    <script>

        import {getHidingGameProxy} from "../../../common/0x/order/ZeroXV3UserPendingOrdersProxy";

        export default {
            config:{
                SWAP: 'SWAP',
                LIMIT: 'LIMIT',
                HIDING_GAME: 'HIDING GAME'
            },
            state: {
                showList: false
            },
            onBeforeMount() {
                this.props.orderFactory.order.tokensChangesObservers.register(this, 'updateDisplay')
                getHidingGameProxy().supportedTokens.observe(this, 'updateDisplay')
            },
            showOrderTypesList() {
                this.update({ showList: !this.state.showList })
            },
            updateDisplay() {
                this.update()
            },
            isOrderSupportedByHidingGame() {
                return getHidingGameProxy().supportedTokens.value
                        .find(t => t.address.toLowerCase() === this.props.orderFactory.order.sellToken.address.toLowerCase()) &&
                    getHidingGameProxy().supportedTokens.value
                        .find(t => t.address.toLowerCase() === this.props.orderFactory.order.buyToken.address.toLowerCase())
            },
            setHidingGameType() {
                this.update({ showList: false })
                if (this.props.orderFactory.order.isMarketOrder()) {
                    this.props.setLimitOrderType(true)
                } else {
                    this.props.orderFactory.toggleHidingGameSupport()
                    this.update()
                }
            },
            setLimitType() {
                this.update({ showList: false })
                this.props.setLimitOrderType(false)
            },
            setSwapType() {
                this.update({ showList: false })
                this.props.setMarketOrderType()
            },
            currentOrderType() {
                if (this.props.orderFactory.order.isMarketOrder()) {
                    return this.config.SWAP
                }

                if (this.props.orderFactory.order.isLimitOrder() && this.props.orderFactory.order.useHidingGame.value ) {
                    return this.config.HIDING_GAME
                }

                return this.config.LIMIT
            }
        }

    </script>

</order-type-selector>